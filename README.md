СПОСОБ ЗАПУСКА ПРОГРАММЫ:

Запуск кода, принимающего аргументы командной строки, возможен 2 способами:
1. Из PyCharm, при открытом ф-ле subnet.py, необходимо перейти к EditConfigurations -> Parameters, указать входные параметры(имя ф-ла и тип адресов)
через пробел, например: IPv6.txt IPv6, нажать Apply, OK. И запустить код на выполнение нажав 'Run'(зеленая стрелка) или 'Shift+F10'.
2. Запуск можно выполнить через консоль, перейдя в директорию с ф-лом subnet.py и ввести(для IPv4):
>> python subnet.py IPv4.txt IPv4  <Enter>


ОЦЕНКА ВРЕМЕННОЙ ЭФФЕКТИВНОСТИ ИСПОЛЬЗУЕМОГО АЛГОРИТМА:

Функция search_subnet() была запущена дважды с разным набором параметров (для "IPv4" и "IPv6"), затраченное на её выполнении время
для обоих вариантов составляет:
The search_subnet() for "IPv4" takes 0.010207607 sec.
The search_subnet() for "IPv6" takes 0.011734283 sec.
Основным фактором, влияющем на время выполнения кода, является количество считанных из ф-ла IP-адресов (для "IPv4" - 3 шт, 
для "IPv6" - 8 шт), до 6-го шага включительно алгоритм обрабатывает все полученные данные.
При достаточно "грубой" оценки можно сделать вывод, что зависимость времени выполнения от кол-ва считанных данных
прямая пропорциональная - О(n), что в общем случае приемлемо. 


ЛОГИКА:

Чтобы получить минимальную подсеть для заданного набора адресов, необходимо определить маску и адрес сети с нулевыми битами, отведенными под
идентификатор хоста.
Для определения маски необходимо из общего кол-ва бит в адресе (32 бита и 128 бит для "IPv4" и "IPv6" соответственно) вычесть
максимальное кол-во бит, занимаемых номером хоста. Принимаю, что номер хоста конкретного адреса начинается с номера октета,
значение которого не совпадает с значением того же номера октета уже следующего IP-адреса. Далее идет сравнение значений в этих октетах.
Максимальное из них переводится в бинарный вид, и определяется максимальное кол-во бит, необходимое чтобы вписать все хосты из
полученного набора IP-адресов. Что позволяет однозначно рассчитать маску и адрес сети.


Алгоритм работы описан с учетом следующих допущений:

- номера шагов в коде соответствуют номерам пунктов алгоритма, описанного в данном ф-ле;
- если какая-либо из проверок на корректность полученных данных не пройдена, то ф-ция завершает
свое выполнение выводом на консоль информации о причине и return None (В алгоритме описаны действия при
успешном прохождении проверок).


АЛГОРИТМ:

1. Работа ф-ции стартует с проверки количества переданных в неё аргументов.
Для корректной работы это кол-во должно быть 3, т.к. 1-й аргумент содержит имя программы и не зависит
от передаваемых нами аргументов, а 2 последующих - это имя ф-ла с набором IP-адресов и версия IP.
Если проверка пройдена, то, в основном для большей читабельности кода, вводятся переменные file_name и type_of_ip.
type_of_ip приводится к нижнему регистру, чтобы продолжить выполнение программы независимо от регистра полученной строки с 
типом IP-адресов (м.б. получено "Ipv4", "IPV4", "ipV4" и т.д.).
2. Проверка соответствия полученного типа IP "IPv4" или "IPv6" с помощью ф-ции check_type_of_ip(type_of_ip), ф-ция возвращает bool.
Полученное имя ф-ла тоже можно проверить на существование, но на данном этапе это не обязательно, т.к. при проверке ф-л может
существовать, а в момент открытия - нет.

3. Выполняется открытие и чтения ф-ла с очисткой содержимого строк от '\n' и добавлением в список адресов(каждый адрес
сохраняется цельной строкой).
Предусмотрена обработка возможного исключения, если ф-л с полученным именем не найден по указанному путиили не существует.

4. Происходит разбиение адресов на отдельные октеты/хекстеты, для дальнейшего сравнивания. 
Данный функционал передан вспомогательной ф-ции get_addr_by_octets(arr_with_addr, type_of_ip), что обусловлено формированием 
адресов для "IPv6" по отдельным правилам (замена одного или нескольких 16-тебитных сегментов, состоящих из 0 на '::').
Ф-ции get_addr_by_octets(arr_with_addr, type_of_ip) адреса "IPv4" разбивает на октеты по символу '.', а  "IPv6" - по ':', на месте '::"
будет '', далее определяется кол-во нулевых хекстетов, создается список с нужным кол-вом '0', и выполняется замена '' на список '0'.

5. Проверка корректности полученных адресов - для "IPv4" должно быть 4 октета, значение каждого октета должно находиться в диапозоне 
от 0 до 255 включительно, для "IPv6" - проверка кол-ва хекстетов (8 шт) и их значение от 0 до 'ffff' == 65535. 
Проверка  делигирована вспомогательной ф-ции check_correct_of_addr(addr, type_of_ip), возвращающей буленовское значение.

6. В соответствии с вышеизложенной логикой производится поиск интекса октета/хекстета в списках адресов, значения которых не совпадают,
что говорит о переходе с сетевой части адреса на часть адреса с идентификатором хоста.
Данный функционал передан вспомогательной ф-ции search_octet_with_host(addresses), реализация которой для обоих типов адресов
идентична. Если значение индекса не найдено - адреса набора полностью одинаковы, то программа завершается из-за невозможности определения 
маски подсети (нет возможности определить максимальное кол-во бит под номер хоста).

7. Определение максимального значения в октете/хекстете с началом хоста (максимальное значение будет забирать больше бит под себя, чем остальные,
поэтому для дальнейшей работы нахотится именно оно).
Данный поиск реализован в вспомогательной ф-ции search_max_num_in_octets(addresses, octet_with_host), реализация которой для обоих типов адресов
идентична.

8. На данном шаге вычисляется кол-во бит, необходимое для хоста, исходя из чего определяется маска подсети. Следует помнить, что для адресов 
IPv4 характерна экономия адресов, поэтому маска будет рассчитана, как разница между общим кол-вом бит на весь адрес(32б) - кол-во бит, отведенное
под хост. Для IPv6 преобладает идея обеспечение иерархической логической структуры сети и маска подсети выравнивается по границе полубайта - 4 бита,
поэтому под хост будет выделено кол-во бит кратное 4, если изначально кратность не соблюдается, то на этом шаге происходит довеление до нее.
Данная логика реализована в вспомогоательной ф-ции get_mask(num, type_of_ip, octet_with_host).

9. Выполняется подготовка к определению IP-адреса сети - октет/хектет с стартовыми биты, отведенными под хост заполняется нулями, определяется 
значение октета/хектета в вспомогательной ф-ции get_net_octet(num, bit_for_host, type_of_ip). Понятно, что если данный октет/хекстет не последний,
то значения всех последующих будут нулевыми.

10. Получение минимальной подсети для считанного набора - результаты предудущих этапов объединяются (определяется IP-адрес сети и к ней добавляется
маска подсети). Данное действие выполнено с учетом правил представления адресов обоих типов и расположено в вспомогательной ф-ции get_result().
